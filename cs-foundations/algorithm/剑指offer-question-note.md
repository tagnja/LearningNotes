Content

Data Structures

- Array List
- String
- Stack & Queue
- Linked List & Binary Tree
- Graph

Algorithms

- Number & Binary
- Sort & Search
- Dynamic Programming
- Backtracking
- Divide and Conquer
- Greedy Algorithm

## Data Structures

### Array List

#### 题3：数组中的重复的数字

- 解法一：简单法。将数组排序后，前后对比即可。T(n) = O(nlogn), S(n) = O(1)
- 解法二：哈希表法。如果数组中的数字的取值范围是已知的，可以利用一个标记数组来记录源数组中数字出现的次数，将元素的值映射到数组的下标。T(n) = O(n), S(n) = O(n)
- 解法三：将数值为 i 的元素放到第 i 个位置中。从头到尾扫描，如果当前元素的数值 i 为当前遍历的下标不相等则，当前下标元素与下标为 i 的元素交换；如果数值与下标相等，则遍历下一个元素。直到找到要交换的元素与被交换的元素相等为止。T(n) = O(n), S(n) = O(1)。[code](https://github.com/zhedahht/CodingInterviewChinese2/blob/master/03_01_DuplicationInArray/FindDuplication.cpp)

#### 题4：二维数组中的查找

二维数组从左到右、从上到下递增的顺序。判断数组中是否包含一个整数。

- 解法一：简单法。遍历每个元素，判断数组中是否包含目标数字。（但没有利用到递增排序的特点）。T(n) = O(n), S(n) = O(1)
- 解法二：每次排除一行或一列。每次去右上角的元素，如果该数字目标数字，则查找结束；如果该数字大于目标数字，剔除这个数字所在的列；如果该数字小于要目标数字，则剔除这个是最所在的行。T(n) = O(n), S(n) = O(1)。 [code]( https://github.com/zhedahht/CodingInterviewChinese2/blob/master/04_FindInPartiallySortedMatrix/FindInPartiallySortedMatrix.cpp )

#### 题21：调整数组顺序使奇数位于偶数前面

输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。

- 解法一：直接法。从头到尾扫描，当遇到偶数，把之后的数字往前移动一个位置，然后把偶数插入到末尾的空位。T(n) = O(n^2), S(n) = O(1)
- 解法二：利用两个指针，第一个指针从头开始找偶数，第二个指针从尾部开始找奇数，找到后交换两个数字的位置。T(n) = O(n)j, S(n) = O(1)

> 类似把数组分成两个部分的题目：所有负数都在非负数的前面，能被3整除的数都在被3

#### 题29：顺时针打印矩阵

输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。如，输入如下矩阵：

```
1  2  3  4 
5  6  7  8
9  10 11 12
13 14 15 16
```

输出的数字顺序为：1，2，3，4，8，12，16，15，14，13，9，5，6，7，11，10

- 解法一：1）把矩阵看成若干个圈，用一个循环来打印矩阵，每次打印矩阵中的一圈。2）把打印一圈分为四步，从左到右，从上到下，从右到左，从下到上。每一步根据起始坐标和终止坐标用一个循环就能打印。3）要考虑最后一圈可能是一横或一竖的情况。

> 把复杂的问题分解成若干个简单的问题。

### String

#### 题5：替换空格

把字符串中的空格替换成“%20”。

- 解法一：从前往后遍历，遇到一个空格插入 “%20”，并且当前位置后面的所有的元素移动两个位置。T(n) = O(n^2), S(n) = O(n)
- 解法二：先算出空格的数量，然后增加字符串的大小，记录最后一个元素的指针和最后一个空位的指针，从最后一个元素开始往后移动，遇到空格插入 “%20”。T(n) = O(n), S(n) = O(n)。[code](https://github.com/zhedahht/CodingInterviewChinese2/blob/master/05_ReplaceSpaces/ReplaceSpaces.cpp)

#### 题19：正则表达式匹配

实现一个函数用来匹配包含 `‘.’` 和 `‘*’` 的正则表达式。`‘.’`表示任意一个字符，`‘*’`表示它前面的字符可以重复出现任意次（含0次）。

- 解法一：使用递归进行求解。1）如果下一个字符是 `*`，可以是移动到下一个状态，可以继续当前状态，可以忽略`*`。2）如果下一个字符不是 `*`，且当前字符与当前模式匹配，或者当前模式为 `.`，移动到下一个状态。3）如果下一个字符不是 `*`，当前字符也不匹配，则返回 false。

#### 题20：表示数值的字符串

实现一个函数判断字符串是否表示数值（包括整数和小数）。字符串“+100”，“5e2”,"-123","3.1416",和“-1E-16” 都表示数值，但“12e”,“1a3.14”,"1.2.3", "+-5"及“12e+5.4” 都不是。可以是正负数，可以是整数和小数，可以是指数。

- 解法一：一个数值字符串可以分为整数部分、小数部分和指数部分。从前到后扫描字符串。1）先处理整数部分，0个或1个加减号，跟着若干个0~9中的数字。2）处理小数部分，小数前面可能没有整数部分`.123`，小数后面可以没有数字`233.`，或者前后都有数字如`233.666`。3）处理指数部分，e或E前面必须**有数字**，后面必须**有整数**。

### Stack & Queue

#### 题9：用两个栈实现队列

分别完成在队列尾部插入和在头部删除的功能。

- 解法一：两个栈两次顺序反转之后刚好时队列的顺序。每个元素都要经历两次入栈和一次出栈。具体操作是：（1）入栈操作，把元素压入 stack1 即可。（2）出栈操作，若 stack2 中有元素，把 stack2 栈顶元素弹出即可；若 stack2 为空，将 stack1 的元素压入 stack2 中，再执行弹出；若两个栈都为空，则弹出空。T(n) = O(1), S(n) = O(1) [code](https://github.com/zhedahht/CodingInterviewChinese2/blob/master/09_QueueWithTwoStacks/QueueWithTwoStacks.cpp)

相关题目：用两个队列实现一个栈

- 解法一：为了满足后进先出，移除队尾前面的所有元素，然后弹出队尾元素，即为后进先出。具体操作是：（1）入队操作，把元素插入不为空的队列尾部。两个队列必定一个为空一个不为空。（2）出队操作，把不为空的队列的尾部元素之前的元素移到另一个队列，把队尾元素弹出。

#### 题31：栈的压入、弹出序列

输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。如，序列{1, 2, 3, 4, 5}是某个栈的压栈序列，序列{4, 5, 3, 2, 1}是该栈的一个弹出序列，但{4, 3, 5, 1, 2}不可能是该栈的弹出序列。

- 解法一：如果下一个弹出的数字刚好是栈顶数字，那么直接弹出；如果下一个弹出的数字不在栈顶，则把没有入栈的数字压入辅助栈，直到把下一个需要弹出的是数字压入栈顶为止；如果所有数字都压入栈后，仍然没有找到下一个弹出数字，那么该序列不可能是一个弹出序列。

### Linked List & Binary Tree

#### 题6：从尾到头打印链表

- 解法一：用栈来实现反向打印。T(n) = O(n), S(n) = O(n)。 [code](https://github.com/zhedahht/CodingInterviewChinese2/blob/master/06_PrintListInReversedOrder/PrintListInReversedOrder.cpp)
- 解法二：类似栈实现的方式，用递归来实现。T(n) = O(n), S(n) = O(1) 

注意：递归的方式看气来更简洁，但是，当链表非常长时，递归可能会导致函数调用栈溢出。用栈实现的代码鲁棒性更好，但需要额外的内存消耗。

#### 题18：删除链表的节点

给定单向链表的头指针和一个节点的指针，实现在 O(1) 时间内删除该节点。

- 解法一：1）当节点不是尾节点时，将下一个节点的值复制到当前节点，然后删除下一个节点。2）当节点是尾节点时，遍历到尾节点上一个节点，然后删除尾节点。

> 删除一个链表节点：1）可以删除当前节点。2）可以复制下一个节点的值到当前节点，然后删除下一个节点。

#### 题22：链表中倒数第K个节点

输入一个链表，输出该链表中倒数第 k 个节点。链表节点定义如下：

```c++
struct ListNode{
	int m_nValue;
	ListNode* m_pNext;
}
```

- 解法一：遍历两次链表。第一次遍历链表，统计链表有多少节点（设为 n），直到总共的节点数 n，倒数第 k 个节点就是顺数 n-k+1 个节点。第二次遍历链表，找到顺数第 n-k+1 个节点。
- 解法二：**使用两个指针**，遍历一次链表。两个指针保持 k-1 的距离，当前面的指针到达尾节点时，后面的指针正好指向倒数第 k 个节点。

> 代码的鲁棒性。需要注意以下情况：1）链表为空。2）链表的节点数小于 k。3）输入的参数 k 为0。

> 当一个指针遍历链表不能解决问题时，可以尝试用两个指针来遍历链表。让其中一个速度快一些，或者让其中一个先走若干步。

#### 题23：链表中环的入口节点

如果一个链表中包含环，请找出环的入口节点。

- 解法一：1）判断链表是否包含环。定义两个指针，它们都从第一个节点出发，一个指针一次走一步，另一个指针每次走两步。两个指针没走一次相差一步，直到相差圆环步数时会相遇说明存在环，没有相遇说明不存在。2）得到环数。相遇后，选两个指针中的任意一个，循环一圈回到原点统计环数。3）找到入口节点。两个相差圆环数的步数的两个指针会在圆环入口节点上相遇。

#### 题24：反转链表

定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。链表为单向链表。

- 解法一：定义 3 个指针，分别指向当前节点，它的前一个节点和后一个节点。

> 代码的鲁棒性。测试用例：1）输入空指针链表。2）输入一个节点的链表。3）输入多个节点的链表。

#### 题25：合并两个排序的链表

输入两个递增排序的链表，合并两个链表并使得新链表时递增排序的。

- 解法一：递归求解。每次从两个链表取出一个最小的节点，这个节点 next 指针指向函数的递归调用。

#### 题35：复杂链表的复制

实现函数 ComplexListNode* Clone(ComplexListNode* pHead)，复制一个复杂链表。在复杂链表中，每个节点除了有一个 m_pNext 指针指向下一个节点，还有一个 m_pSibling 指针指向链表中的任意节点或者 nullptr。节点定义如下：

```cpp
struct ComplexListNode{
    int m_nValue;
    ComplexListNode* m_pNext;
    ComplexListNode* m_pSibling;
};
```

- 解法一：第一步，复制原始链表上的每个节点，并用 m_pNext 链接起来。第二步，设置每个节点的 m_pSibling 指针，在原始链表中从头到尾找到 m_pSibling 离首节点的距离。然后设置复制链表上的 m_pSibling。T(n) = O(n^2), S(n) = O(1)。
- 解法二：第一步复制原始链表上的每个节点用 m_pNext 指针链接起来。第二步，把 <N, N'> 原始节点和对应复制节点的配对信息放到一个哈希表中。通过哈希表可以通过 O(1) 的时间设置 m_pSibling 指针。但是需要额外的 O(n) 的空间消耗。T(n) = O(n), S(n) = O(n)。
- 解法三：第一步，根据原始链表的每个节点 N，创建对应的 N'。把 N' 链接在 N 的后面。如，A -> A' -> B -> B'...。 第二步，根据原始 m_pSibling 指针指向的元素的下一个元素来设置复制原始的 m_pSibling 指针。第三步，将链表拆成两个链表。这种方法时间和空间都是最优的。T(n) = O(n), S(n) = O(1)。



#### 题7：重建二叉树

输入某个二叉树的前序遍历和中序遍历的结果，请重建该二叉树。

- 解法一：由前序遍历的第一元素直到根节点，根据中序遍历知道左子树和右子树。用递归的方式依次找到所有的子树的根节点，并建立根节点与左右子树的指针。 [code](https://github.com/zhedahht/CodingInterviewChinese2/blob/master/07_ConstructBinaryTree/ConstructBinaryTree.cpp)

#### 题8：二叉树的下一个节点

给定一个二叉树的节点，找出中序遍历序列的下一个节点。树中右指向左右子节点的指针，还有指向父节点的指针。

- 解法一：分类处理。（1）如果一个节点有右子树，那么它的下一个节点是它的右子树的最左节点。（2）如果一个节点没有右子树，该节点是它父节点的左子节点，那么它的下一个节点就是它的父节点。（3）如果一个节点没有右子树，且它是它的父节点的右子节点。一直向上遍历，直到找到一个是它父节点的左子节点的节点。如果这样的节点存在，那么这个节点的父节点就是我们要找的下一个节点。T(n) = O(n), S(n) = O(1)。 [code](https://github.com/zhedahht/CodingInterviewChinese2/blob/master/08_NextNodeInBinaryTrees/NextNodeInBinaryTrees.cpp)

二叉树的下一个节点情况比较复杂。需要分析归类清晰。

#### 题26：树的子结构

输入两棵二叉树 A 和 B，判断 B 是不是 A 的子结构。二叉树节点的定义如下：

```cpp
struct BinaryTreeNode{
    double m_dbValue;
    BinaryTreeNode n_pLeft;
    BinaryTreeNode n_pRight;
}
```

- 解法一：1）在树 A 中遍历查找与 B 根节点值一样的节点。2）判断树 A 以 R 为根节点的子树和树 B 是不是相同的结构。

> 注意边界条件检查，即检查空指针。

#### 题27：二叉树的镜像

输入一棵二叉树，输出它的镜像。

```
    8                   8
 6     10            10    6
5  7  9  11        11  9  7  5
```

二叉树节点定义如下：

```cpp
struct BinaryTreeNode{
    int m_nValue;
    BinaryTreeNode* m_pLeft;
    BinaryTreeNode* m_pRight;
}
```

- 解法一：从根节点开始，交换它的两个子节点，然后递归调用子节点。最后所有的左右子节点都交换了位置，得到二叉树的镜像。

#### 题28：对称的二叉树

判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。

```
    8
  6    6
5  7  7  5  
```

- 解法一：通过比较二叉树的前序遍历序列和对称前序遍历序列是否一样，来判断二叉树是不是对称的。

#### 题32：从上到下打印二叉树

题目一：不分行从上到下打印二叉树。

从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。

- 解法一：使用队列从上到下打印二叉树。1. 先将根节点入队，队列中有一个根节点元素。2. 然后 while 循环每次弹出队首的一个节点，压入弹出节点的左右子节点，直到队列中没有元素。
- （本质上是广度优先遍历二叉树）

题目二：分行从上到下打印二叉树。

从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。

- 解法一：使用队列来保存将要打印的节点。分行打印，需要两个变量，一个变量 toBePrint 表示当层中还没有打印的节点数，另一个变量 nextLevel 表示下一层节点的数目。1. 先将根节点入队，队列中有一个根节点元素，初始化 toBePrint  变量为1。2. 然后 while 循环每次弹出队首的一个节点，toBePrint 减一，压入弹出节点的左右子节点，每压入一个子节点 nextLevel 变量加1，如果 toBePrint 变量为0则打印一个换行符，直到队列中没有元素。

题目三：之字形分行打印二叉树

之字形分行打印二叉树，即第一行从左到右，第二行从右到左，第三行从左到右，以此类推。

- 解法一：每次相反的顺序想到使用栈。使用两个栈来实现，一个存储当前层，一个存储下一层。1. 初始化，创建长度为2的栈数组，将根节点压入当前层栈中。2. 循环操作，打印当前层栈的栈顶元素，压入弹出节点的左右子节点到下一层栈中，如果当前栈元素为空则打印换行符并交换当前层和下一层栈的变量参考。

#### 题33：二叉搜索树的后序遍历序列

输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。加入数组中的每个元素互不相同。如果是则返回 true，否则返回 false。

- 解法一：根据最后一个元素为根节点，可以将序列分为两个部分，左边的都小于它，右边的都大于它。通过递归依次检查左右子树是否是搜索树。

#### 题34：二叉树中和为某一值的路径

输入一棵二叉树和一个整数，打印出二叉树中节点值得和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成的一条路径。（节点结构只有左右子节点的指针）

- 解法一：使用递归或栈先序遍历二叉树，用一个数组来保存路径以便打印路径。每当遍历到叶子节点时，判断当前路径所有节点的和是否等于输入的整数。如果是则打印路径，不是则回到父节点走另一条路径。

#### 题36：二叉搜索树与双向链表

输入一棵二叉搜索树，将该二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。二叉树节点的定义如下：

```cpp
struct BinaryTreeNode{
    int m_nValue;
    BinaryTreeNode m_pLeft;
    BinaryTreeNode m_pRight;
};
```

- 解法一：二叉搜索树每个节点有两个指针，以及它是有序的，所以可以转换成排序的双向链表。通过递归求解，把二叉搜索树分成三个部分，左子树，根节点，右子树，把左子树和右子树转换成排序后的双链表之后再和根节点链接起来。

#### 题37：序列化二叉树

实现两个函数，分别用来序列化和反序列化二叉树。





### Graph





## Algorithms



### Number & Binary

#### 题15：二进制中的1的个数

输入一个整数，输出该数二进制表示中数字1的个数。

- 解法一：直接法。将数字 n 转换为二进制字符串，然后计算1出现的次数。
- 解法二：直接法。将数字 n 与数字1进行与位运算，判断数字 n 的最后一位是不是1。然后将数字1左移一位继续与数字 n 进行与位运算去判断数字 n 的倒数第二位是不是1。依次判断数字 n 的每一位是不是 1。
- 解法三：简单的位运算。将不断进行 n = (n - 1) & n，直到 n = 0，执行多少次说明数字 n 的二进制中有多少个数字 1。 

#### 题16：数值的整数次方

实现函数 double power(double base, int exponent)，求 base 的 exponent 次方，不能使用库函数，同时不需要考虑大数问题。

> （细节题）由于 0 的 0 次方数学上无意义，以及 0 不能作为分母，要考虑 base 为 0 的情况，以及 exponent 为正数，负数和零的情况。解法很简单，就是要分情况讨论有点麻烦。

- 解法一：1）如果 exponent >= 0，将 base 循环乘 exponent 次。2）如果 exponent < 0，将 base 乘 abs(exponent) 次，然后取倒数。

#### 题17：打印从1到最大的 n 位数

输入数字n，按顺序打印从1 到最大的n位数十进制数。

如输入3，输出 1，2，... 999。

> 陷阱题。需要考虑大数问题。可以使用字符串来处理。

- 解法一：定义 n 位字符串，每一位初始化为0。实现一个将字符串加1的方法，实现一个将字符串的数字部分打印出来的方法。如 n = 3，字符串初始化为 “000”，然后执行加 1 操作，字符串为 “001”，打印字符串为 1。
- 解法二：使用数字排列的解法，可以利用递归让代码更简洁。每次循环输出 0~9，递归调用输出下一位，直到每一位都赋值时结束递归，打印结果。

### Sort & Search

#### 题11：旋转数组的最小数字

把一个数组最开始的若干个元素移动到数组的末尾，称之为数组的旋转。题为输入一个递增排序的数组的一个旋转，输入旋转数组中的最小元素。

- 解法一：使用二分查找处理。（1）特例：若第一个元素是数组中最小元素，第一个数字小于最后一个数字，则直接返回第一个元素。（2）旋转之后的数组可以划分为两个排序的子数组，前面子数组的元素都大于或等于后面子数组的元素。可以使用二分查找缩小范围，找到中间那个最小的元素。使用两个指针，第一个指针 P1 指向前面子数组的元素，第二指针 P2 指向后面子数组的元素，刚开始 P1 指向第一个元素，P2 指向最后一个元素，如果 P1 和 P2 中间的元素大于 P1 则，P1 指向中间的元素，小于P1则 P2 指向中间的元素。通过不断缩短范围，最后 P1 指向前面子数组的最大的元素，P2 指向后面子数组最小的元素。最后结果返回 P2 指向的元素即可。（3）若步骤二出现特例情况，即当中间元素等于 P1 也等于 P2 时，不知道该如何缩小范围，我们则采用顺序查找，从 P1 位置到 P2 位置顺序查找，找到它们之间的最小值。T(n) = O(nlogn), S(n) = O(1)。[code](https://github.com/zhedahht/CodingInterviewChinese2/blob/master/11_MinNumberInRotatedArray/MinNumberInRotatedArray.cpp)



### Dynamic Programming & Greedy Algorithm

#### 题10：斐波那契数列

求斐波那契数列的第n项。

- 解法一：根据斐波那契的函数，写出简单的递归。T(n) = O(n^2), S(n)=O(1)
- 解法二：利用动态规划自底向上的方法。它去除了递归中的重复计算。T(n) = O(n), S(n) = O(1)。[code](https://github.com/zhedahht/CodingInterviewChinese2/blob/master/10_Fibonacci/Fibonacci.cpp)

#### 题14：减绳子

一根长度为 n 的绳子，把绳子剪成 m 段（m、n都是整数，n>1，m>1），每段绳子最小长度为1，求所有绳子段长度可能的最大乘积是多少。当长度为8时，最大的乘积为 18 = 2\*3\*3.

- 解法一：动态规划。由等式 `f(n)=max(f(i) * f(n-i))`，手动算出 f(0) = 0, f(1)=1,f(2)=2, f(3) = 3，然后自定向上求解所有的 f(i)。最后返回 f(n)。T(n) = O(n), S(n) = O(1)。[code](https://github.com/zhedahht/CodingInterviewChinese2/blob/master/14_CuttingRope/CuttingRope.cpp)
- 解法二：贪婪算法。当 n>=5 时，尽可能多剪长度为3的绳子段，当剩下的绳子长度为4时，把绳子剪成长度为2的绳子段。 [code](https://github.com/zhedahht/CodingInterviewChinese2/blob/master/14_CuttingRope/CuttingRope.cpp)



### Backtracking

经典问题：

- N-Queen: O(n!)
- Graph Coloring: O(nm^n)
- Hamilton Cycle: O(N!)
- WordBreak and StringSegment: O(2^N)
- Subset Sum: O(nW)

#### 题12：矩阵中的路径

判断一个矩阵中的字符是否存在一条包含字符串所有字符的路径。每一步可以上下左右移动一格，每个格子只能走一次。

- 解法一：典型的回溯问题。（1）任意一个格子作为起点。（2）如果路径上的第 i 个字符不是字符串中的第 i 个字符则回溯到上一个位置。（3）如果路径上的第 i 个字符时字符串中的第 i 个字符则寻找路径上的第 i+1 个字符。（4）重复第二步和第三步过程，直到路径上的所有字符都在矩阵上找到响应的位置。T(n) = O(3^n), S(n) = O(1)。[code](https://github.com/zhedahht/CodingInterviewChinese2/blob/master/12_StringPathInMatrix/StringPathInMatrix.cpp)

#### 题13：机器人的运动范围

有一个m行n列的方格。一个机器人从坐标(0, 0) 的格子开始移动，每次可以向上下左右移动一格，但不能进入坐标的数位之和大于 k 的格子。如 k = 18时，机器人可以进入方格 (35, 37)，因为 3+5+3+7=18 <= k，求机器人一共能够达到多少个格子。

- 解法一：类似回溯的题目，但没有回溯，只是递归求解。递归判断下一个方格是否能进入，若能则结果加1。T(n) = O(3^(mn)), S(n) = O(1)。[code](https://github.com/zhedahht/CodingInterviewChinese2/blob/master/13_RobotMove/RobotMove.cpp) 



### Divide and Conquer 



## Summary

习惯性思维

- Data Structures Thinking Habits
  - Reverse Sequence 要想到 Stack or Recursion
  - Graph 要想到 DFS or BFS
- Algorithms Thinking Habits
  - Path in matrix 要想到 backtracking
  - Sorted List 要想到 Binary Search

注意事项

- 递归可能导致函数调用栈溢出。
- 算术表达式的数值可能溢出，集合下标的是否超过范围，链表的指针是否是空指针。

## References

[1] 剑指Offer 第二版 by 何海涛

[2] [剑指Offer 第二版源代码](https://github.com/zhedahht/CodingInterviewChinese2)