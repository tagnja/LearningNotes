Content

Data Structures

- Array List
- String
- Stack & Queue
- Linked List & Binary Tree
- Graph

Algorithms

- Number & Binary
- Sort & Search
- Dynamic Programming
- Backtracking
- Divide and Conquer
- Greedy Algorithm

## Data Structures

### Array List

#### 题3：数组中的重复的数字

- 解法一：简单法。将数组排序后，前后对比即可。T(n) = O(nlogn), S(n) = O(1)
- 解法二：哈希表法。如果数组中的数字的取值范围是已知的，可以利用一个标记数组来记录源数组中数字出现的次数，将元素的值映射到数组的下标。T(n) = O(n), S(n) = O(n)
- 解法三：将数值为 i 的元素放到第 i 个位置中。从头到尾扫描，如果当前元素的数值 i 为当前遍历的下标不相等则，当前下标元素与下标为 i 的元素交换；如果数值与下标相等，则遍历下一个元素。直到找到要交换的元素与被交换的元素相等为止。T(n) = O(n), S(n) = O(1)。[code](https://github.com/zhedahht/CodingInterviewChinese2/blob/master/03_01_DuplicationInArray/FindDuplication.cpp)

#### 题4：二维数组中的查找

二维数组从左到右、从上到下递增的顺序。判断数组中是否包含一个整数。

- 解法一：简单法。遍历每个元素，判断数组中是否包含目标数字。（但没有利用到递增排序的特点）。T(n) = O(n), S(n) = O(1)
- 解法二：每次排除一行或一列。每次去右上角的元素，如果该数字目标数字，则查找结束；如果该数字大于目标数字，剔除这个数字所在的列；如果该数字小于要目标数字，则剔除这个是最所在的行。T(n) = O(n), S(n) = O(1)。 [code]( https://github.com/zhedahht/CodingInterviewChinese2/blob/master/04_FindInPartiallySortedMatrix/FindInPartiallySortedMatrix.cpp )

#### 题21：调整数组顺序使奇数位于偶数前面

输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。

- 解法一：直接法。从头到尾扫描，当遇到偶数，把之后的数字往前移动一个位置，然后把偶数插入到末尾的空位。T(n) = O(n^2), S(n) = O(1)
- 解法二：利用两个指针，第一个指针从头开始找偶数，第二个指针从尾部开始找奇数，找到后交换两个数字的位置。T(n) = O(n)j, S(n) = O(1)

> 类似把数组分成两个部分的题目：所有负数都在非负数的前面，能被3整除的数都在被3

#### 题29：顺时针打印矩阵

输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。如，输入如下矩阵：

```
1  2  3  4 
5  6  7  8
9  10 11 12
13 14 15 16
```

输出的数字顺序为：1，2，3，4，8，12，16，15，14，13，9，5，6，7，11，10

- 解法一：1）把矩阵看成若干个圈，用一个循环来打印矩阵，每次打印矩阵中的一圈。2）把打印一圈分为四步，从左到右，从上到下，从右到左，从下到上。每一步根据起始坐标和终止坐标用一个循环就能打印。3）要考虑最后一圈可能是一横或一竖的情况。

> 把复杂的问题分解成若干个简单的问题。

### String

#### 题5：替换空格

把字符串中的空格替换成“%20”。

- 解法一：从前往后遍历，遇到一个空格插入 “%20”，并且当前位置后面的所有的元素移动两个位置。T(n) = O(n^2), S(n) = O(n)
- 解法二：先算出空格的数量，然后增加字符串的大小，记录最后一个元素的指针和最后一个空位的指针，从最后一个元素开始往后移动，遇到空格插入 “%20”。T(n) = O(n), S(n) = O(n)。[code](https://github.com/zhedahht/CodingInterviewChinese2/blob/master/05_ReplaceSpaces/ReplaceSpaces.cpp)

#### 题19：正则表达式匹配

实现一个函数用来匹配包含 `‘.’` 和 `‘*’` 的正则表达式。`‘.’`表示任意一个字符，`‘*’`表示它前面的字符可以重复出现任意次（含0次）。

- 解法一：使用递归进行求解。1）如果下一个字符是 `*`，可以是移动到下一个状态，可以继续当前状态，可以忽略`*`。2）如果下一个字符不是 `*`，且当前字符与当前模式匹配，或者当前模式为 `.`，移动到下一个状态。3）如果下一个字符不是 `*`，当前字符也不匹配，则返回 false。

#### 题20：表示数值的字符串

实现一个函数判断字符串是否表示数值（包括整数和小数）。字符串“+100”，“5e2”,"-123","3.1416",和“-1E-16” 都表示数值，但“12e”,“1a3.14”,"1.2.3", "+-5"及“12e+5.4” 都不是。可以是正负数，可以是整数和小数，可以是指数。

- 解法一：一个数值字符串可以分为整数部分、小数部分和指数部分。从前到后扫描字符串。1）先处理整数部分，0个或1个加减号，跟着若干个0~9中的数字。2）处理小数部分，小数前面可能没有整数部分`.123`，小数后面可以没有数字`233.`，或者前后都有数字如`233.666`。3）处理指数部分，e或E前面必须**有数字**，后面必须**有整数**。

### Stack & Queue

#### 题9：用两个栈实现队列

分别完成在队列尾部插入和在头部删除的功能。

- 解法一：两个栈两次顺序反转之后刚好时队列的顺序。每个元素都要经历两次入栈和一次出栈。具体操作是：（1）入栈操作，把元素压入 stack1 即可。（2）出栈操作，若 stack2 中有元素，把 stack2 栈顶元素弹出即可；若 stack2 为空，将 stack1 的元素压入 stack2 中，再执行弹出；若两个栈都为空，则弹出空。T(n) = O(1), S(n) = O(1) [code](https://github.com/zhedahht/CodingInterviewChinese2/blob/master/09_QueueWithTwoStacks/QueueWithTwoStacks.cpp)

相关题目：用两个队列实现一个栈

- 解法一：为了满足后进先出，移除队尾前面的所有元素，然后弹出队尾元素，即为后进先出。具体操作是：（1）入队操作，把元素插入不为空的队列尾部。两个队列必定一个为空一个不为空。（2）出队操作，把不为空的队列的尾部元素之前的元素移到另一个队列，把队尾元素弹出。

#### 题30：包含 min 函数的栈

#### 题31：栈的压入、弹出序列



### Linked List & Binary Tree

#### 题6：从尾到头打印链表

- 解法一：用栈来实现反向打印。T(n) = O(n), S(n) = O(n)。 [code](https://github.com/zhedahht/CodingInterviewChinese2/blob/master/06_PrintListInReversedOrder/PrintListInReversedOrder.cpp)
- 解法二：类似栈实现的方式，用递归来实现。T(n) = O(n), S(n) = O(1) 

注意：递归的方式看气来更简洁，但是，当链表非常长时，递归可能会导致函数调用栈溢出。用栈实现的代码鲁棒性更好，但需要额外的内存消耗。

#### 题18：删除链表的节点

给定单向链表的头指针和一个节点的指针，实现在 O(1) 时间内删除该节点。

- 解法一：1）当节点不是尾节点时，将下一个节点的值复制到当前节点，然后删除下一个节点。2）当节点是尾节点时，遍历到尾节点上一个节点，然后删除尾节点。

> 删除一个链表节点：1）可以删除当前节点。2）可以复制下一个节点的值到当前节点，然后删除下一个节点。

#### 题22：链表中倒数第K个节点

输入一个链表，输出该链表中倒数第 k 个节点。链表节点定义如下：

```c++
struct ListNode{
	int m_nValue;
	ListNode* m_pNext;
}
```

- 解法一：遍历两次链表。第一次遍历链表，统计链表有多少节点（设为 n），直到总共的节点数 n，倒数第 k 个节点就是顺数 n-k+1 个节点。第二次遍历链表，找到顺数第 n-k+1 个节点。
- 解法二：**使用两个指针**，遍历一次链表。两个指针保持 k-1 的距离，当前面的指针到达尾节点时，后面的指针正好指向倒数第 k 个节点。

> 代码的鲁棒性。需要注意以下情况：1）链表为空。2）链表的节点数小于 k。3）输入的参数 k 为0。

> 当一个指针遍历链表不能解决问题时，可以尝试用两个指针来遍历链表。让其中一个速度快一些，或者让其中一个先走若干步。

#### 题23：链表中环的入口节点

如果一个链表中包含环，请找出环的入口节点。

- 解法一：1）判断链表是否包含环。定义两个指针，它们都从第一个节点出发，一个指针一次走一步，另一个指针每次走两步。两个指针没走一次相差一步，直到相差圆环步数时会相遇说明存在环，没有相遇说明不存在。2）得到环数。相遇后，选两个指针中的任意一个，循环一圈回到原点统计环数。3）找到入口节点。两个相差圆环数的步数的两个指针会在圆环入口节点上相遇。

#### 题24：反转链表

定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。链表为单向链表。

- 解法一：定义 3 个指针，分别指向当前节点，它的前一个节点和后一个节点。

> 代码的鲁棒性。测试用例：1）输入空指针链表。2）输入一个节点的链表。3）输入多个节点的链表。

#### 题25：合并两个排序的链表

输入两个递增排序的链表，合并两个链表并使得新链表时递增排序的。

- 解法一：递归求解。每次从两个链表取出一个最小的节点，这个节点 next 指针指向函数的递归调用。



#### 题7：重建二叉树

输入某个二叉树的前序遍历和中序遍历的结果，请重建该二叉树。

- 解法一：由前序遍历的第一元素直到根节点，根据中序遍历知道左子树和右子树。用递归的方式依次找到所有的子树的根节点，并建立根节点与左右子树的指针。 [code](https://github.com/zhedahht/CodingInterviewChinese2/blob/master/07_ConstructBinaryTree/ConstructBinaryTree.cpp)

#### 题8：二叉树的下一个节点

给定一个二叉树的节点，找出中序遍历序列的下一个节点。树中右指向左右子节点的指针，还有指向父节点的指针。

- 解法一：分类处理。（1）如果一个节点有右子树，那么它的下一个节点是它的右子树的最左节点。（2）如果一个节点没有右子树，该节点是它父节点的左子节点，那么它的下一个节点就是它的父节点。（3）如果一个节点没有右子树，且它是它的父节点的右子节点。一直向上遍历，直到找到一个是它父节点的左子节点的节点。如果这样的节点存在，那么这个节点的父节点就是我们要找的下一个节点。T(n) = O(n), S(n) = O(1)。 [code](https://github.com/zhedahht/CodingInterviewChinese2/blob/master/08_NextNodeInBinaryTrees/NextNodeInBinaryTrees.cpp)

二叉树的下一个节点情况比较复杂。需要分析归类清晰。

#### 题26：树的子结构

输入两棵二叉树 A 和 B，判断 B 是不是 A 的子结构。二叉树节点的定义如下：

```cpp
struct BinaryTreeNode{
    double m_dbValue;
    BinaryTreeNode n_pLeft;
    BinaryTreeNode n_pRight;
}
```

- 解法一：1）在树 A 中遍历查找与 B 根节点值一样的节点。2）判断树 A 以 R 为根节点的子树和树 B 是不是相同的结构。

> 注意边界条件检查，即检查空指针。

#### 题27：二叉树的镜像

输入一棵二叉树，输出它的镜像。

```
    8                   8
 6     10            10    6
5  7  9  11        11  9  7  5
```

二叉树节点定义如下：

```cpp
struct BinaryTreeNode{
    int m_nValue;
    BinaryTreeNode* m_pLeft;
    BinaryTreeNode* m_pRight;
}
```

- 解法一：从根节点开始，交换它的两个子节点，然后递归调用子节点。最后所有的左右子节点都交换了位置，得到二叉树的镜像。

#### 题28：对称的二叉树

判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。

```
    8
  6    6
5  7  7  5  
```

- 解法一：通过比较二叉树的前序遍历序列和对称前序遍历序列是否一样，来判断二叉树是不是对称的。



### Graph





## Algorithms



### Number & Binary

#### 题15：二进制中的1的个数

输入一个整数，输出该数二进制表示中数字1的个数。

- 解法一：直接法。将数字 n 转换为二进制字符串，然后计算1出现的次数。
- 解法二：直接法。将数字 n 与数字1进行与位运算，判断数字 n 的最后一位是不是1。然后将数字1左移一位继续与数字 n 进行与位运算去判断数字 n 的倒数第二位是不是1。依次判断数字 n 的每一位是不是 1。
- 解法三：简单的位运算。将不断进行 n = (n - 1) & n，直到 n = 0，执行多少次说明数字 n 的二进制中有多少个数字 1。 

#### 题16：数值的整数次方

实现函数 double power(double base, int exponent)，求 base 的 exponent 次方，不能使用库函数，同时不需要考虑大数问题。

> （细节题）由于 0 的 0 次方数学上无意义，以及 0 不能作为分母，要考虑 base 为 0 的情况，以及 exponent 为正数，负数和零的情况。解法很简单，就是要分情况讨论有点麻烦。

- 解法一：1）如果 exponent >= 0，将 base 循环乘 exponent 次。2）如果 exponent < 0，将 base 乘 abs(exponent) 次，然后取倒数。

#### 题17：打印从1到最大的 n 位数

输入数字n，按顺序打印从1 到最大的n位数十进制数。

如输入3，输出 1，2，... 999。

> 陷阱题。需要考虑大数问题。可以使用字符串来处理。

- 解法一：定义 n 位字符串，每一位初始化为0。实现一个将字符串加1的方法，实现一个将字符串的数字部分打印出来的方法。如 n = 3，字符串初始化为 “000”，然后执行加 1 操作，字符串为 “001”，打印字符串为 1。
- 解法二：使用数字排列的解法，可以利用递归让代码更简洁。每次循环输出 0~9，递归调用输出下一位，直到每一位都赋值时结束递归，打印结果。

### Sort & Search

#### 题11：旋转数组的最小数字

把一个数组最开始的若干个元素移动到数组的末尾，称之为数组的旋转。题为输入一个递增排序的数组的一个旋转，输入旋转数组中的最小元素。

- 解法一：使用二分查找处理。（1）特例：若第一个元素是数组中最小元素，第一个数字小于最后一个数字，则直接返回第一个元素。（2）旋转之后的数组可以划分为两个排序的子数组，前面子数组的元素都大于或等于后面子数组的元素。可以使用二分查找缩小范围，找到中间那个最小的元素。使用两个指针，第一个指针 P1 指向前面子数组的元素，第二指针 P2 指向后面子数组的元素，刚开始 P1 指向第一个元素，P2 指向最后一个元素，如果 P1 和 P2 中间的元素大于 P1 则，P1 指向中间的元素，小于P1则 P2 指向中间的元素。通过不断缩短范围，最后 P1 指向前面子数组的最大的元素，P2 指向后面子数组最小的元素。最后结果返回 P2 指向的元素即可。（3）若步骤二出现特例情况，即当中间元素等于 P1 也等于 P2 时，不知道该如何缩小范围，我们则采用顺序查找，从 P1 位置到 P2 位置顺序查找，找到它们之间的最小值。T(n) = O(nlogn), S(n) = O(1)。[code](https://github.com/zhedahht/CodingInterviewChinese2/blob/master/11_MinNumberInRotatedArray/MinNumberInRotatedArray.cpp)



### Dynamic Programming & Greedy Algorithm

#### 题10：斐波那契数列

求斐波那契数列的第n项。

- 解法一：根据斐波那契的函数，写出简单的递归。T(n) = O(n^2), S(n)=O(1)
- 解法二：利用动态规划自底向上的方法。它去除了递归中的重复计算。T(n) = O(n), S(n) = O(1)。[code](https://github.com/zhedahht/CodingInterviewChinese2/blob/master/10_Fibonacci/Fibonacci.cpp)

#### 题14：减绳子

一根长度为 n 的绳子，把绳子剪成 m 段（m、n都是整数，n>1，m>1），每段绳子最小长度为1，求所有绳子段长度可能的最大乘积是多少。当长度为8时，最大的乘积为 18 = 2\*3\*3.

- 解法一：动态规划。由等式 `f(n)=max(f(i) * f(n-i))`，手动算出 f(0) = 0, f(1)=1,f(2)=2, f(3) = 3，然后自定向上求解所有的 f(i)。最后返回 f(n)。T(n) = O(n), S(n) = O(1)。[code](https://github.com/zhedahht/CodingInterviewChinese2/blob/master/14_CuttingRope/CuttingRope.cpp)
- 解法二：贪婪算法。当 n>=5 时，尽可能多剪长度为3的绳子段，当剩下的绳子长度为4时，把绳子剪成长度为2的绳子段。 [code](https://github.com/zhedahht/CodingInterviewChinese2/blob/master/14_CuttingRope/CuttingRope.cpp)



### Backtracking

经典问题：

- N-Queen: O(n!)
- Graph Coloring: O(nm^n)
- Hamilton Cycle: O(N!)
- WordBreak and StringSegment: O(2^N)
- Subset Sum: O(nW)

#### 题12：矩阵中的路径

判断一个矩阵中的字符是否存在一条包含字符串所有字符的路径。每一步可以上下左右移动一格，每个格子只能走一次。

- 解法一：典型的回溯问题。（1）任意一个格子作为起点。（2）如果路径上的第 i 个字符不是字符串中的第 i 个字符则回溯到上一个位置。（3）如果路径上的第 i 个字符时字符串中的第 i 个字符则寻找路径上的第 i+1 个字符。（4）重复第二步和第三步过程，直到路径上的所有字符都在矩阵上找到响应的位置。T(n) = O(3^n), S(n) = O(1)。[code](https://github.com/zhedahht/CodingInterviewChinese2/blob/master/12_StringPathInMatrix/StringPathInMatrix.cpp)

#### 题13：机器人的运动范围

有一个m行n列的方格。一个机器人从坐标(0, 0) 的格子开始移动，每次可以向上下左右移动一格，但不能进入坐标的数位之和大于 k 的格子。如 k = 18时，机器人可以进入方格 (35, 37)，因为 3+5+3+7=18 <= k，求机器人一共能够达到多少个格子。

- 解法一：类似回溯的题目，但没有回溯，只是递归求解。递归判断下一个方格是否能进入，若能则结果加1。T(n) = O(3^(mn)), S(n) = O(1)。[code](https://github.com/zhedahht/CodingInterviewChinese2/blob/master/13_RobotMove/RobotMove.cpp) 



### Divide and Conquer 



## Summary

习惯性思维

- Data Structures Thinking Habits
  - Reverse Sequence 要想到 Stack or Recursion
  - Graph 要想到 DFS or BFS
- Algorithms Thinking Habits
  - Path in matrix 要想到 backtracking
  - Sorted List 要想到 Binary Search

注意事项

- 递归可能导致函数调用栈溢出。
- 算术表达式的数值可能溢出，集合下标的是否超过范围，链表的指针是否是空指针。

## References

[1] 剑指Offer 第二版 by 何海涛

[2] [剑指Offer 第二版源代码](https://github.com/zhedahht/CodingInterviewChinese2)